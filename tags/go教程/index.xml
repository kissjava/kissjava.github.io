<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go教程 on 清风徐来</title>
    <link>/tags/go%E6%95%99%E7%A8%8B/</link>
    <description>Recent content in Go教程 on 清风徐来</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>kissjava.cn</copyright>
    <lastBuildDate>Tue, 30 Jul 2019 22:06:59 +0000</lastBuildDate>
    
	<atom:link href="/tags/go%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>高级Go测试教程</title>
      <link>/posts/%E9%AB%98%E7%BA%A7go%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/</link>
      <pubDate>Tue, 30 Jul 2019 22:06:59 +0000</pubDate>
      
      <guid>/posts/%E9%AB%98%E7%BA%A7go%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/</guid>
      <description>本教程中，我们将介绍Go语言更高级测试实践。</description>
    </item>
    
    <item>
      <title>Go的单元测试</title>
      <link>/posts/go%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 30 Jul 2019 19:00:00 +0000</pubDate>
      
      <guid>/posts/go%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>测试在所有软件中都非常重要。 能够确保代码的正确性并确保您所做的任何更改最终都不会破坏代码库中任何其他部分的内容，这非常重要。
##目标
在本教程结束时，您将掌握使用标准testing包，测试Go中的基本函数和方法。
在本教程中，我们将介绍如何使用go test命令为您的go代码开发和运行测试。
##Go的测试文件
如果您之前看过一些go项目，您可能已经注意到大多数（如果不是全部）的项目，Go代码文件都在同一目录中具有FILE_test.go对应项。
这些文件包含项目的所有单元测试，测试其对应的所有代码
简单的项目机构
myproject/- calc.go- calc_test.go- main.go- main_test.go##一个简单的测试文件
假如我们有一个非常简单的go程序，它由一个文件组成，并具有calculate（）函数。这个calculate（）函数只需要1个参数，返回加2后的结果。让我们开始运行 main.go
package mainimport (&amp;quot;fmt&amp;quot;)// 计算 returns x + 2.func Calculate(x int) (result int) {result = x + 2return result}func main() {fmt.Println(&amp;quot;Hello World&amp;quot;)}如果想要进行测试，我们可以在同一目录中创建一个main_test.go文件并编写以下测试： main_test.go
package mainimport (&amp;quot;testing&amp;quot;)func TestCalculate(t *testing.T) {if Calculate(2) != 4 {t.</description>
    </item>
    
    <item>
      <title>Go解析XML文件</title>
      <link>/posts/go%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 30 Jul 2019 17:28:00 +0000</pubDate>
      
      <guid>/posts/go%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</guid>
      <description>在本教程中，我们将介绍如何有效读取XML文件，使用Go的encoding / xml包解析xml，遍历多个嵌套的xml元素，然后将其打印到终端
##XML示例文件
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&amp;lt;users&amp;gt;&amp;lt;user type=&amp;quot;admin&amp;quot;&amp;gt;&amp;lt;name&amp;gt;Elliot&amp;lt;/name&amp;gt;&amp;lt;social&amp;gt;&amp;lt;facebook&amp;gt;https://facebook.com&amp;lt;/facebook&amp;gt;&amp;lt;twitter&amp;gt;https://twitter.com&amp;lt;/twitter&amp;gt;&amp;lt;youtube&amp;gt;https://youtube.com&amp;lt;/youtube&amp;gt;&amp;lt;/social&amp;gt;&amp;lt;/user&amp;gt;&amp;lt;user type=&amp;quot;reader&amp;quot;&amp;gt;&amp;lt;name&amp;gt;Fraser&amp;lt;/name&amp;gt;&amp;lt;social&amp;gt;&amp;lt;facebook&amp;gt;https://facebook.com&amp;lt;/facebook&amp;gt;&amp;lt;twitter&amp;gt;https://twitter.com&amp;lt;/twitter&amp;gt;&amp;lt;youtube&amp;gt;https://youtube.com&amp;lt;/youtube&amp;gt;&amp;lt;/social&amp;gt;&amp;lt;/user&amp;gt;&amp;lt;/users&amp;gt;##完成代码部分
package mainimport (&amp;quot;encoding/xml&amp;quot;&amp;quot;fmt&amp;quot;&amp;quot;io/ioutil&amp;quot;&amp;quot;os&amp;quot;)type Users struct {XMLName xml.Name `xml:&amp;quot;users&amp;quot;`Users []User `xml:&amp;quot;user&amp;quot;`}type User struct {XMLName xml.Name `xml:&amp;quot;user&amp;quot;`Type string `xml:&amp;quot;type,attr&amp;quot;`Name string `xml:&amp;quot;name&amp;quot;`Social Social `xml:&amp;quot;social&amp;quot;`}type Social struct {XMLName xml.</description>
    </item>
    
    <item>
      <title>Go解析JSON文件</title>
      <link>/posts/go%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 30 Jul 2019 08:49:10 +0000</pubDate>
      
      <guid>/posts/go%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6/</guid>
      <description>在本教程中，我们将了解如何读取JSON文件或JSON HTTP响应并根据需要解析它们。 我们可以使用XML或JSON表示相同的信息，但JSON提供了一个优势，它更紧凑，并且在我的个人经验中，更具可读性。
JSON现在是最流行的数据格式，大多数RESTful API都会提供JSON响应。因此本文非常有用！
##Encoding/Json Package
我们将利用encoding / json标准库包来启动和运行。我强烈建议你在这里查看官方文档：Encoding / Json。
##读取和解析JSON文件
user.json
{&amp;quot;users&amp;quot;: [{&amp;quot;name&amp;quot;: &amp;quot;Elliot&amp;quot;,&amp;quot;type&amp;quot;: &amp;quot;Reader&amp;quot;,&amp;quot;age&amp;quot;: 23,&amp;quot;social&amp;quot;: {&amp;quot;facebook&amp;quot;: &amp;quot;https://facebook.com&amp;quot;,&amp;quot;twitter&amp;quot;: &amp;quot;https://twitter.com&amp;quot;}},{&amp;quot;name&amp;quot;: &amp;quot;Fraser&amp;quot;,&amp;quot;type&amp;quot;: &amp;quot;Author&amp;quot;,&amp;quot;age&amp;quot;: 17,&amp;quot;social&amp;quot;: {&amp;quot;facebook&amp;quot;: &amp;quot;https://facebook.com&amp;quot;,&amp;quot;twitter&amp;quot;: &amp;quot;https://twitter.com&amp;quot;}}]}###读取JSON文件 使用os包来从我们的文件系统中打开users.json文件。打开文件后，我们将关闭文件（函数结束时执行defer后的关闭）。
jsonFile, err := os.Open(&amp;quot;users.json&amp;quot;)if err != nil {fmt.Println(err)}fmt.Println(&amp;quot;成功打开 users.json&amp;quot;)// 推迟关闭我们的jsonFile，以便稍后解析它defer jsonFile.Close()###用结构解析
我们可以用结构或是map[string]interface{}来解析users.json。我们用结构，上代码：</description>
    </item>
    
    <item>
      <title>使用Golang执行系统命令</title>
      <link>/posts/%E4%BD%BF%E7%94%A8golang%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 29 Jul 2019 22:43:00 +0000</pubDate>
      
      <guid>/posts/%E4%BD%BF%E7%94%A8golang%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid>
      <description>在本教程中，我们将看一下标准库中的os / exec包以及如何使用它在Go应用程序中成功执行系统命令。 ##条件
您需要安装Go 1.11+版本
##兼容性问题
只是简单的教程Demo，所以并未对所有平台适用。
###检查当前操作系统 我们可以使用runtime包并检查GOOS常量。这将返回目标的操作系统：
 if runtime.GOOS == &amp;quot;windows&amp;quot; {fmt.Println(&amp;quot;无法在Windows机器上执行此操作&amp;quot;)} else {execute()}##上代码
package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;os/exec&amp;quot;&amp;quot;runtime&amp;quot;)func execute() {// 这里我们执行pwd命令// 我们可以将它的输出存储在我们的out变量中out, err := exec.Command(&amp;quot;ls&amp;quot;).Output()// 如果我们的执行有错误if err != nil {fmt.Printf(&amp;quot;%s&amp;quot;, err)}// 因为上面定义的out变量是[] byte类型，// 我们需要将它转换为字符串，否则我们将看到在我们的控制台中打印出乱码// 这就是我们将它转​​换为字符串的方式fmt.Println(&amp;quot;命令已成功执行&amp;quot;)output := string(out[:])fmt.Println(output)// 让我们试试pwd命令out, err = exec.Command(&amp;quot;pwd&amp;quot;).Output()if err !</description>
    </item>
    
    <item>
      <title>Go从Console读取输入</title>
      <link>/posts/go%E4%BB%8Econsole%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5/</link>
      <pubDate>Mon, 29 Jul 2019 22:24:00 +0000</pubDate>
      
      <guid>/posts/go%E4%BB%8Econsole%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5/</guid>
      <description>##一个简单的shell 一个示例的shell，没啥用：
package mainimport (&amp;quot;bufio&amp;quot;&amp;quot;fmt&amp;quot;&amp;quot;os&amp;quot;&amp;quot;strings&amp;quot;)func main() {reader := bufio.NewReader(os.Stdin)fmt.Println(&amp;quot;Simple Shell&amp;quot;)fmt.Println(&amp;quot;---------------------&amp;quot;)for {fmt.Print(&amp;quot;-&amp;gt; &amp;quot;)text, _ := reader.ReadString(&#39;\n&#39;)// 将CRLF转换为LFtext = strings.Replace(text, &amp;quot;\n&amp;quot;, &amp;quot;&amp;quot;, -1)// 如果windows，要用下面的// text = strings.Replace(text, &amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;, -1)if strings.Compare(&amp;quot;hi&amp;quot;, text) == 0 {fmt.Println(&amp;quot;hello, Yourself&amp;quot;)}if strings.Compare(&amp;quot;bye&amp;quot;, text) == 0 {fmt.Println(&amp;quot;Bye.&amp;quot;)break}}}输入hi，它会打个招呼；输入bye，退出shell。
##读取单个UTF-8编码的Unicode字符
package mainimport (&amp;quot;bufio&amp;quot;&amp;quot;fmt&amp;quot;&amp;quot;os&amp;quot;)func main() {reader := bufio.</description>
    </item>
    
    <item>
      <title>在Go中读取和写入文件</title>
      <link>/posts/%E5%9C%A8go%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 29 Jul 2019 21:56:00 +0000</pubDate>
      
      <guid>/posts/%E5%9C%A8go%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</guid>
      <description>在本教程中，我们将介绍如何使用go语言有效地读取和写入文件系统中的文件。
我们将用于读取和写入这些文件的方法将与文件格式无关。这意味着你将能够使用我们将要覆盖的技术来读写，.txt，.csv，.xls等，这些文件唯一不同的是您写入每种文件类型的数据结构。
##读取文件
main.go
package main// 导入我们需要的2个模块import (&amp;quot;fmt&amp;quot;&amp;quot;io/ioutil&amp;quot;)func main() {// 读取文件 localfile.data 的内容data, err := ioutil.ReadFile(&amp;quot;localfile.data&amp;quot;)// 如果我们的程序无法读取该文件// 打印出它不能读取的原因if err != nil {fmt.Println(err)}// 如果读取成功，将内容打印为字符串fmt.Print(string(data))}##将文件写入新文件 我们已经介绍了Go中的文件读取，现在是时候看看创建和写入我们自己的文件了！ 代码说话：
package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;io/ioutil&amp;quot;)func main() {mydata := []byte(&amp;quot;All the data I wish to write to a file&amp;quot;)// 如果不成功，WriteFile方法返回错误err := ioutil.WriteFile(&amp;quot;myfile.data&amp;quot;, mydata, 0777)// 处理错误，打印出来if err !</description>
    </item>
    
    <item>
      <title>Go的接口</title>
      <link>/posts/go%E7%9A%84%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 29 Jul 2019 19:33:00 +0000</pubDate>
      
      <guid>/posts/go%E7%9A%84%E6%8E%A5%E5%8F%A3/</guid>
      <description>在本教程中，我们将看看Go编程语言中的接口。 本节包括2个主题：
 接口的基本知识 定义我们自己的接口  ##简单案例
如果您看到一个需要空接口的函数或方法，那么您通常可以将任何内容传递给此函数/方法。
package mainimport (&amp;quot;fmt&amp;quot;)func myFunc(a interface{}) {fmt.Println(a)}func main() {var my_age intmy_age = 25myFunc(my_age)}运行它
$ go run main.go25###有什么作用 通过定义interface{}的函数，我们基本上可以灵活地传递任何我们想要的东西。这个函数接受了一些东西，但我们不一定需要关心它的类型是什么。
##定义接口 那么，什么是接口？为什么我们在Go中使用它们？好吧，通过在Go中定义一个接口，我们基本上定义了一个契约。如果我们根据此接口定义类型，那么我们将必须实现该接口类型中定义的所有函数或方法。
比如说，我们想为吉他手定义一个interface。我们可以定义我们的接口以包含PlayGuitar（）函数，如下所示：
type Guitarist interface {// PlayGuitar在终端打印出“弹吉他”PlayGuitar()}通过定义我们的吉他手interface，我们可以定义一个BaseGuitarist和一个AcousticGuitarist结构。
package mainimport &amp;quot;fmt&amp;quot;type Guitarist interface {PlayGuitar()}type BaseGuitarist struct {Name string}type AcousticGuitarist struct {Name string}func (b BaseGuitarist) PlayGuitar() {fmt.</description>
    </item>
    
    <item>
      <title>Go的方法</title>
      <link>/posts/go%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 29 Jul 2019 18:52:00 +0000</pubDate>
      
      <guid>/posts/go%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>在本教程中，我们将首先了解哪些方法以及它们如何在Go编程语言的范围内工作。然后，我们将看看揭开方法和函数之间的差异，以及何时在Go程序中使用它们。 ##一个简单实例 我们将创建一个非常简单的员工管理系统，允许您更新员工姓名并打印出该名称。不是最令人兴奋的示例项目，但它将作为演示还可以。
我们首先创建一个Employee类型的结构，它包含一个字符串字段Name
接下来，我们将声明一个UpdateName()和一个PrintName()方法，它允许我们更新和打印我们创建的员工的姓名。
package mainimport (&amp;quot;fmt&amp;quot;)type Employee struct {Name string}func (e *Employee) UpdateName(newName string) {e.Name = newName}func (e *Employee) PrintName() {fmt.Println(e.Name)}func main() {var employee Employeeemployee.Name = &amp;quot;Michael&amp;quot;employee.UpdateName(&amp;quot;Mike&amp;quot;)employee.PrintName()}与函数一样，方法会创建传递给它的参数的副本。为避免这种情况，我们可以在定义方法时使用指针接收器func (pointer *Pointer) myMethod()。指针指向内存地址，是传递的引用。多用用就回习惯了，不像C的指针那么恐怖。
为什么我们在Go程序中使用方法呢？
##函数vs方法
方法通常作用于给定的对象，即player.Update（params），这种方式比用UpdatePlayer（player，params）更优雅和直观。
func UpdatePlayer(player *Player, params ParamsStruct) {fmt.Println(&amp;quot;这是个简单的函数&amp;quot;)}UpdatePlayer(player, params)上面需要传入player和其它参数，下面的方式更加明了：
func (g *Player) Update(params ParamsStruct) {fmt.</description>
    </item>
    
    <item>
      <title>Go的函数</title>
      <link>/posts/go%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 29 Jul 2019 17:37:00 +0000</pubDate>
      
      <guid>/posts/go%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>在本教程中，我们将学习Golang中的函数，并希望在本教程结束时，您将牢牢掌握它们是什么以及如何在您自己的项目中使用它们。 我们将在本教程中介绍以下主题：
 函数声明的基础知识 使用多个返回值  ##函数的声明 Go中的所有函数都以func关键字开始，然后是函数名称。在名称之后，我们打开括号并定义我们的参数列表，后跟一个非常相似的返回结果列表：
func name(parameter-list) (result-list) {// 函数体} 访问权限！如果您希望在其他包中访问您的函数，那么您必须将函数名称的第一个字母设为大写！
 ##举个栗子 对于这个例子，我们将创建一个名为myFunction的函数，它将接收2个字符串参数并返回结果字符串：
func myfunction(firstName string, lastName string) (string) {fullname := firstName + &amp;quot; &amp;quot; + lastName return fullname}在函数体的第一行，我们创建了一个名为fullname的新变量，它是我们的firstName变量与空格和我们的lastName变量连接成的新字符串。完成此连接后，我们将返回fullname变量。
##完整的代码
package mainimport (&amp;quot;fmt&amp;quot;)func myfunction(firstName string, lastName string) (string) {fullname := firstName + &amp;quot; &amp;quot; + lastName return fullname}func main() {fmt.Println(&amp;quot;Hello World&amp;quot;)fullName := myfunction(&amp;quot;Michael&amp;quot;, &amp;quot;Yang&amp;quot;)fmt.</description>
    </item>
    
    <item>
      <title>Go的复合数据类型</title>
      <link>/posts/go%E7%9A%84%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 29 Jul 2019 17:13:00 +0000</pubDate>
      
      <guid>/posts/go%E7%9A%84%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>上节我们学过来基本数据类型，本节说说go的复合数据类型。
##数组 Arrays 让我们首先声明一周中所有天的数组。
// 声明一个空数组的字符串var days []string// 声明一个包含元素的数组days := [...]string{&amp;quot;monday&amp;quot;, &amp;quot;tuesday&amp;quot;, &amp;quot;wednesday&amp;quot;, &amp;quot;thursday&amp;quot;, &amp;quot;friday&amp;quot;, &amp;quot;saturday&amp;quot;, &amp;quot;sunday&amp;quot;}如果我们想查询数组中的第一个元素或特定元素，我们可以以与其他语言非常相似的方式查询：
fmt.Println(days[0]) // 打印 &#39;monday&#39;fmt.Println(days[5]) // 打印 &#39;saturday&#39;##切片 Slices 切片和数组之间的区别非常微妙。 Go中的切片允许您访问底层数组元素的子集。
切片由三个部分组成，指针，长度length和容量capactiy。让我们试着用一个例子来形象化。比方说，例如，我们有一个星期几的数组，我们可以使用切片来仅提取那些工作日的天数。
days := [...]string{&amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;, &amp;quot;Sunday&amp;quot;}weekdays := days[0:5]fmt.Println(weekdays)// 这会返回: [Monday Tuesday Wednesday Thursday Friday]##映射 Maps 映射是Go表示的哈希表，这是一种允许您将一种任意数据类型映射到另一种数据的数据结构。例如，让我们根据该频道的订阅者数量创建 YouTube频道名称=&amp;gt;订阅数量 的Map：
youtubeSubscribers := map[string]int{&amp;quot;TutorialEdge&amp;quot;: 2240,&amp;quot;MKBHD&amp;quot;: 6580350,&amp;quot;Fun Fun Function&amp;quot;: 171220,}fmt.</description>
    </item>
    
    <item>
      <title>Go的基本数据类型</title>
      <link>/posts/go%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 29 Jul 2019 15:47:00 +0000</pubDate>
      
      <guid>/posts/go%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>在本教程中，我们将学习Go语言中可用的所有基本数据类型。在本教程结束时，您应该熟悉该语言中提供的各种不同类型，并希望了解如何在您自己的Go程序中使用这些类型。 ps：本节课程很无聊，但是不可或缺。
##数据类型 Go编程语言中有4种不同类型的类型
 基本类型 我们将在本教程中介绍的内容 聚合类型 数组和结构 引用类型 指针和切片 接口类型 标准接口  ##整型
简单点，直接在代码里注释讲解吧
// 所有数字类型默认为0// 无符号的8位整型// 可存储: 0 to 255var myint uint8// 有符号的8位整型// 可存储: -127 to 127var myint int8// 无符号的16位整型var myint uint16// 有符号的16位整型var myint int16// 无符号的32位整型var myint uint32// 带符号的32位整型var myint int32// 无符号的64位整型var myint uint64// 带符号的64位整型var myint int64存储超过大小的值编译会无法通过。初始存储未超过大小，但是运行中溢出了，可能会出现其它结果：
package mainimport (&amp;quot;fmt&amp;quot;)func main() {fmt.</description>
    </item>
    
    <item>
      <title>Go入门</title>
      <link>/posts/go%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 29 Jul 2019 14:58:00 +0000</pubDate>
      
      <guid>/posts/go%E5%85%A5%E9%97%A8/</guid>
      <description>希望是无废话的go语言教程。 Go是一种绝对令人难以置信的语言，可以构建各种不同的应用程序。从命令行界面到分布式微系统甚至云平台，它的简单性和并发性使其成为许多开发团队的强大语言选择。
在本教程中，我将着手帮助您启动并运行该语言，以便您可以开始构建更加出色的应用程序并推动技术的发展。
我们将专注于启动和运行一个非常简单的Hello World风格的应用程序。一旦你掌握了一切正常的工作，我们就可以开始学习语言中更复杂的方面，比如函数，方法，以及最终的并发和反射等方面。
您需要在开发计算机上安装Go。如果您需要安装，请查看官方下载页面：官方下载
##入门
让我们深入了解安装好所有内容并编写一个非常简单的程序来让我们热热身。
您首先要进入官方的入门页面，其中包含一个链接，用于安装目前可用的各种不同版本的Go。
使用官方安装文件安装，把Go的可执行文件添加到您机器的PATH中。完成后，我们应该能够在终端中运行go version：
$ go versiongo version go1.12.5 darwin/amd64如果正常，我们就准备开始编写自己的Go程序。
打开代码编辑器，然后创建一个新的目录，我们的Hello World项目将存在该目录中。
在这个目录中，我们将创建一个名为main.go的新文件，它将包含我们相对简单的Go程序。我们还想在这个目录打开一个终端并运行以下命令：
$ GOMODULES11=ON$ go mod init github.com/hello/world这将初始化我们的项目，并允许我们将来的Go代码分成子包。它还允许我们以最小的麻烦来检索我们可能想要的任何外部依赖项。就是用go module来管理包依赖。
现在，在我们的main.go文件中，我们将要添加以下代码：
// 每个go源文件的第一个语句// 必须是包裹声明。如果我们什么都不做// 一般就是main包package main// 我们想要使用fmt包// 它具有`print`功能 - Printlnimport &amp;quot;fmt&amp;quot;// 我们需要定义我们的main函数// 把它想象成我们Go的切入点，就是程序入口func main() {// 在main函数中，我们调用fmt的Println函数打印出Hello Worldfmt.Println(&amp;quot;Hello World&amp;quot;)}我们可直接运行。
$ go run main.goHello World或是编译成二进制文件后再运行
$ go build main.</description>
    </item>
    
  </channel>
</rss>